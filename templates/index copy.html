<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>aswa: Music Recommendation System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
</head>
<body class="m-0 h-screen flex flex-col overflow-hidden relative bg-black/50 font-sans">

<!-- Navigation Bar -->
<nav class="relative flex justify-between items-center py-0 px-0 bg-[rgba(20,20,20,0.85)] shadow-md z-50">
    <!-- White ASWA Logo Section -->
    <div class="h-full bg-white px-6 py-3">
        <a href="/" class="text-black text-2xl font-bold select-none tracking-widest" style="font-family: 'Futura', 'Helvetica Neue', Arial, sans-serif;">( a . s . w . a )</a>
    </div>
    <!-- Navigation Links -->
    <div class="flex gap-4 items-center mr-6">
        <a href="/login" class="nav-link text-white/85 no-underline text-center font-medium py-2 px-3 rounded transition-all duration-200 hover:text-white hover:bg-white/10 flex items-center gap-2" style="font-family: 'Futura', 'Helvetica Neue', Arial, sans-serif; letter-spacing: 0.05em;">
            <i class="fas fa-sign-in-alt"></i>
            <span>LOGIN</span>
        </a>
        <a href="/liked_music" class="nav-link text-white/85 no-underline text-center font-medium py-2 px-3 rounded transition-all duration-200 hover:text-white hover:bg-white/10 flex items-center gap-2" style="font-family: 'Futura', 'Helvetica Neue', Arial, sans-serif; letter-spacing: 0.05em;">
            <i class="fas fa-heart"></i>
            <span>PLAYLIST</span>
        </a>
        <a href="/moodboard" class="nav-link text-white/85 no-underline text-center font-medium py-2 px-3 rounded transition-all duration-200 hover:text-white hover:bg-white/10 flex items-center gap-2" style="font-family: 'Futura', 'Helvetica Neue', Arial, sans-serif; letter-spacing: 0.05em;">
            <i class="fas fa-palette"></i>
            <span>MOOD</span>
        </a>
        <a href="/analytics" class="nav-link text-white/85 no-underline text-center font-medium py-2 px-3 rounded transition-all duration-200 hover:text-white hover:bg-white/10 flex items-center gap-2" style="font-family: 'Futura', 'Helvetica Neue', Arial, sans-serif; letter-spacing: 0.05em;">
            <i class="fas fa-chart-line"></i>
            <span>STATS</span>
        </a>
        {% if test_mode %}
        <span class="bg-yellow-500 text-black py-1 px-3 rounded-full text-xs font-bold flex items-center" style="font-family: 'Futura', 'Helvetica Neue', Arial, sans-serif;">
            <i class="fas fa-vial mr-1"></i> TEST MODE
        </span>
        {% endif %}
    </div>
</nav>


    
    <div id="background-container" class="absolute top-0 left-0 w-full h-full bg-center bg-cover bg-no-repeat blur-md opacity-50 z-[1]" style="background-image: url('{{ album_image }}');"></div>
    
    <div class="flex-1 flex justify-center items-center relative z-[5]">
        <!-- Skip Area (Left) - Updated with higher contrast background -->
        <div id="dislike-area" class="absolute top-0 h-full w-1/2 left-0 z-[5] cursor-pointer transition-colors duration-300 bg-red-500/15 hover:bg-red-500/40 group">
            <!-- Skip overlay (top-left) -->
            <div class="absolute top-8 left-8 flex flex-col items-center opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                <i class="fas fa-times text-7xl text-white"></i>
                <span class="mt-2 text-xl font-normal text-white">SKIP</span>
            </div>
        </div>
    
        <!-- Like Area (Right) - Updated with higher contrast background -->
        <div id="like-area" class="absolute top-0 h-full w-1/2 right-0 z-[5] cursor-pointer transition-colors duration-300 bg-green-500/15 hover:bg-green-500/40 group">
            <!-- Like overlay (top-right) -->
            <div class="absolute top-8 right-8 flex flex-col items-center opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                <i class="fas fa-heart text-7xl text-white"></i>
                <span class="mt-2 text-xl font-normal text-white">LIKE</span>
            </div>
        </div>
    
        <!-- Postcard Content -->
        <div class="relative w-4/5 max-w-md flex flex-col items-center z-10 my-auto mx-auto">
            <div id="postcard" class="w-full bg-white/90 shadow-xl rounded-2xl overflow-hidden relative z-10 flex flex-col text-left select-none">
                
                <!-- Album cover -->
                <div class="w-full h-auto overflow-hidden relative">
                    <img id="album-cover" draggable="false" src="{{ album_image }}" alt="Album Cover" class="w-full aspect-square object-cover select-none">
                </div>

                <!-- Text content -->
                <div class="flex flex-col justify-between p-6 bg-gradient-to-b from-white/90 to-white/95 w-full items-start text-left">
                    <div class="flex-1 flex flex-col justify-center space-y-3 w-full">
                        <div id="track-title" class="text-2xl font-semibold text-gray-800 leading-tight tracking-tight">
                            {{ album_title }}
                        </div>
                        <div id="artist-name" class="text-xl font-normal text-gray-700">
                            {{ artists }}
                        </div>
                        <div id="album-details" class="text-base text-gray-500">
                            {{ album_details }}
                        </div>
                    </div>

                    <!-- Deezer logo -->
                    <div class="flex justify-between items-center w-full mt-5 pt-4 border-t border-gray-200">
                        <a id="album-link" href="{{ album_link }}" target="_blank" class="flex items-center text-blue-600 hover:text-blue-800">
                            <img class="h-6 pointer-events-none select-none" 
                                src="https://upload.wikimedia.org/wikipedia/commons/7/75/Deezer_logo%2C_2023.svg" 
                                alt="Deezer">
                            <span class="text-xs ml-2 text-gray-500">Listen on Deezer</span>
                        </a>
                        
                        <!-- Explicit Indicator - Fixed -->
                        <div id="is-explicit" class="text-xs font-bold px-2 py-1 rounded 
                            {% if album_isexplicit %}
                                bg-red-100 text-red-700
                            {% else %}
                                bg-gray-100 text-gray-300
                            {% endif %}">
                            EXPLICIT
                        </div>
                    </div>
                </div>

                <!-- Audio -->
                {% if not test_mode %}
                <audio id="preview-player" src="{{ preview_url }}" autoplay loop class="w-full"></audio>
                <div class="w-full h-1 bg-gray-200">
                    <div id="audio-progress" class="h-full bg-gradient-to-r from-purple-500 to-blue-500 w-0"></div>
                </div>
                {% else %}
                <div id="test-mode-notice" class="absolute bottom-2 right-2 bg-yellow-400 text-black px-2 py-1 text-xs rounded font-medium">
                    Test Mode: Audio Disabled
                </div>
                {% endif %}
            </div>
        </div>
    </div>
    
    <div id="progress-overlay" class="absolute bottom-0 left-0 w-0 h-12 blur-[0.5px] bg-white/40 transition-[width] duration-[0.4s] ease-linear"></div>
    <div id="toast" class="fixed bottom-[30px] left-1/2 -translate-x-1/2 bg-gray-800 text-white py-3 px-6 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-100"></div>

    <script>
        // Tracks data from server
const tracks = {{ tracks | tojson | safe }};
let currentTrackIndex = 0;
const testMode = {{ test_mode|tojson }};

// DOM Elements
const player = document.getElementById('preview-player');
const backgroundContainer = document.getElementById('background-container');
const albumCover = document.getElementById('album-cover');
const trackTitle = document.getElementById('track-title');
const artistName = document.getElementById('artist-name');
const albumDetails = document.getElementById('album-details');
const progressOverlay = document.getElementById('progress-overlay');
const dislikeArea = document.getElementById('dislike-area');
const likeArea = document.getElementById('like-area');
const postcard = document.getElementById('postcard');
const toast = document.getElementById('toast');
const isExplicit = document.getElementById('is-explicit');
const albumLink = document.getElementById('album-link');

// Touch handling variables
let startX = 0;
let endX = 0;
let isSwiping = false;
const minSwipeDistance = 100; // Minimum distance for a swipe to be registered

async function updateTrackInfo(track) {
    albumCover.src = track.cover_xl;
    backgroundContainer.style.backgroundImage = `url('${track.cover_xl}')`;
    trackTitle.textContent = track.title; // Fixed: removed the (E) from the title
    artistName.textContent = track.artist;
    albumDetails.textContent = track.album;
    
    // Fix 1: Update explicit indicator properly
    if (track.is_explicit) {
        isExplicit.textContent = 'EXPLICIT';
        isExplicit.classList.remove('bg-gray-100', 'text-gray-300');
        isExplicit.classList.add('bg-red-100', 'text-red-700');
    } else {
        isExplicit.textContent = 'EXPLICIT';
        isExplicit.classList.remove('bg-red-100', 'text-red-700');
        isExplicit.classList.add('bg-gray-100', 'text-gray-300');
    }
    
    // Fix 3: Update the album link for each track
    albumLink.href = track.link;
    
    if (!testMode && player) {
        player.src = track.preview;
        player.play().catch(err => {
            console.warn("Audio autoplay prevented:", err);
            showToast("Click to enable audio playback");
        });
    }

    // Store the current track properly in the tracks array
    if (!tracks.find(t => t.id_deezer === track.id_deezer)) {
        tracks.push(track);
    }
    
    // Find the index of the current track by id_deezer
    currentTrackIndex = tracks.findIndex(t => t.id_deezer === track.id_deezer);
    if (currentTrackIndex === -1) currentTrackIndex = 0;
    
    // Debug log
    console.log("Updated to track:", track.id_deezer, track.title);
}

function animateSlide(direction) {
    if (direction === 'left') {
        postcard.classList.add('translate-x-full', 'opacity-0', 'transition-all', 'duration-300', 'ease-in');
        setTimeout(() => {
            postcard.classList.remove('translate-x-full', 'opacity-0');
            postcard.classList.add('-translate-x-full', 'opacity-0');
        }, 300);
    } else {
        postcard.classList.add('-translate-x-full', 'opacity-0', 'transition-all', 'duration-300', 'ease-in');
        setTimeout(() => {
            postcard.classList.remove('-translate-x-full', 'opacity-0');
            postcard.classList.add('translate-x-full', 'opacity-0');
        }, 300);
    }
    
    setTimeout(() => {
        postcard.classList.remove('translate-x-full', '-translate-x-full', 'opacity-0', 'transition-all', 'duration-300', 'ease-in');
    }, 600);
}

function showToast(message) {
    toast.textContent = message;
    toast.classList.add('opacity-100');
    setTimeout(() => {
        toast.classList.remove('opacity-100');
    }, 3000);
}

// Track double-click events
let lastClickTime = 0;
const doubleClickDelay = 300; // milliseconds

async function handleLike() {
    try {
        const currentTrack = tracks[currentTrackIndex];
        // Make sure we have the current track
        if (!currentTrack) {
            console.error("No current track found at index", currentTrackIndex);
            showToast("Error: No track selected");
            return;
        }
        
        // Use id_deezer as the consistent ID field
        const trackId = currentTrack.id_deezer;
        console.log('Liking track:', trackId, currentTrack.title);
        
        const saveResponse = await fetch('/save_track', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                track_id: trackId,
                id_deezer: trackId,
                title: currentTrack.title,
                artist: currentTrack.artist,
                album: currentTrack.album,
                cover: currentTrack.cover_xl,
                preview: currentTrack.preview,
                link: currentTrack.link,
                is_explicit: currentTrack.is_explicit || false
            })
        });
        
        if (saveResponse.ok) {
            const saveData = await saveResponse.json();
            showToast(saveData.message || 'Track added to playlist!');
        } else {
            const errorData = await saveResponse.json();
            showToast(errorData.error || 'Error saving track');
        }
        
        // Add test_mode to URL params if we're in test mode
        const testParam = testMode ? '&test_mode=true' : '';
        const nextResponse = await fetch(`/next_track${testParam}`);
        if (!nextResponse.ok) {
            throw new Error('Failed to fetch next track');
        }
        
        const track = await nextResponse.json();
        animateSlide('left');
        
        // Important: we need to wait for animation to complete
        // THEN update the track info to ensure we're showing the right track
        setTimeout(() => {
            updateTrackInfo(track);
            // Reset currentTrack to the new track
            currentTrack = tracks[currentTrackIndex];
        }, 300);
    } catch (error) {
        console.error('Error saving or fetching track:', error);
        showToast('Error processing track');
    }
}

async function handleDislike() {
    try {
        const currentTrack = tracks[currentTrackIndex];
        if (!currentTrack) {
            console.error("No current track found at index", currentTrackIndex);
            showToast("Error: No track selected");
            return;
        }
        
        const trackId = currentTrack.id_deezer;
        console.log('Disliking track:', trackId, currentTrack.title);
        
        // Add test_mode to URL params if we're in test mode
        const testParam = testMode ? '&test_mode=true' : '';
        
        // Fetch next track
        const response = await fetch(`/next_track?track_id=${trackId}${testParam}`);
        if (!response.ok) {
            throw new Error('Failed to fetch next track');
        }
        
        const track = await response.json();
        animateSlide('right');
        
        // Wait for animation to complete, then update track info
        setTimeout(() => {
            updateTrackInfo(track);
            // Reset currentTrack to the new track
            currentTrack = tracks[currentTrackIndex];
        }, 300);
        
        showToast('Track skipped!');
    } catch (error) {
        console.error('Error fetching next track:', error);
        showToast('Error skipping track');
    }
}

// Dislike Area (Left Side) - Click handling
dislikeArea.addEventListener('click', (event) => {
    const currentTime = new Date().getTime();
    if (currentTime - lastClickTime < doubleClickDelay) {
        // Double click detected
        handleDislike();
    }
    lastClickTime = currentTime;
});

// Like Area (Right Side) - Click handling
likeArea.addEventListener('click', (event) => {
    const currentTime = new Date().getTime();
    if (currentTime - lastClickTime < doubleClickDelay) {
        // Double click detected
        handleLike();
    }
    lastClickTime = currentTime;
});

// Touch event handling for swiping
postcard.addEventListener('touchstart', (e) => {
    startX = e.touches[0].clientX;
    isSwiping = true;
    
    // Reset any ongoing transitions
    postcard.style.transition = 'none';
    postcard.style.transform = 'translateX(0)';
    postcard.style.rotate = '0deg';
});

postcard.addEventListener('touchmove', (e) => {
    if (!isSwiping) return;
    
    const x = e.touches[0].clientX;
    const diff = x - startX;
    
    // Make the card follow the finger with some resistance
    const moveX = diff * 0.8;
    postcard.style.transform = `translateX(${moveX}px)`;
    
    // Add rotation effect for more natural feel
    const rotation = moveX * 0.05;
    postcard.style.rotate = `${rotation}deg`;
    
    // Fix 2: Make the background highlights more visible with higher opacity values
    if (diff > 50) {
        // Swiping right (like) - darker green
        likeArea.style.backgroundColor = 'rgba(71, 250, 0, 0.4)';
        dislikeArea.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
    } else if (diff < -50) {
        // Swiping left (dislike) - darker red
        dislikeArea.style.backgroundColor = 'rgba(255, 0, 0, 0.4)';
        likeArea.style.backgroundColor = 'rgba(71, 250, 0, 0.1)';
    } else {
        // Neutral
        likeArea.style.backgroundColor = 'rgba(71, 250, 0, 0.1)';
        dislikeArea.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
    }
});

postcard.addEventListener('touchend', (e) => {
    if (!isSwiping) return;
    isSwiping = false;
    
    // Reset transition for smooth animation
    postcard.style.transition = 'transform 0.3s ease, rotate 0.3s ease';
    
    // Get the final position
    endX = e.changedTouches[0].clientX;
    const diff = endX - startX;
    
    if (diff > minSwipeDistance) {
        // Swiped right (like)
        postcard.style.transform = 'translateX(150%)';
        postcard.style.rotate = '10deg';
        
        // Wait for animation to complete before handling like
        setTimeout(() => {
            handleLike();
            
            // Reset postcard position
            postcard.style.transition = 'none';
            postcard.style.transform = 'translateX(0)';
            postcard.style.rotate = '0deg';
            setTimeout(() => {
                postcard.style.transition = 'transform 0.3s ease, rotate 0.3s ease';
            }, 50);
        }, 300);
    } else if (diff < -minSwipeDistance) {
        // Swiped left (dislike)
        postcard.style.transform = 'translateX(-150%)';
        postcard.style.rotate = '-10deg';
        
        // Wait for animation to complete before handling dislike
        setTimeout(() => {
            handleDislike();
            
            // Reset postcard position
            postcard.style.transition = 'none';
            postcard.style.transform = 'translateX(0)';
            postcard.style.rotate = '0deg';
            setTimeout(() => {
                postcard.style.transition = 'transform 0.3s ease, rotate 0.3s ease';
            }, 50);
        }, 300);
    } else {
        // Not enough distance, snap back
        postcard.style.transform = 'translateX(0)';
        postcard.style.rotate = '0deg';
    }
    
    // Reset background colors to match the default state
    likeArea.style.backgroundColor = 'rgba(71, 250, 0, 0.1)';
    dislikeArea.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
});

// Progress bar function
function updateProgress() {
    if (!player || !player.duration) return;
    let progress = (player.currentTime / player.duration) * 100;
    progressOverlay.style.width = `${progress.toFixed(2)}%`;
}

// Only set up audio-related event listeners if we're not in test mode
if (!testMode && player) {
    player.addEventListener('timeupdate', updateProgress);
    
    player.addEventListener('ended', () => {
        progressOverlay.style.transition = 'none';
        progressOverlay.style.width = '0%';
        setTimeout(() => {
            progressOverlay.style.transition = 'width 0.5s linear';
        }, 50);
    });
}

// Keyboard Controls
document.addEventListener('keydown', (event) => {
    switch(event.code) {
        case 'Space':
            event.preventDefault();
            if (player && !testMode) {
                if (player.paused) {
                    player.play();
                } else {
                    player.pause();
                }
            }
            break;
        case 'ArrowLeft':
            // Trigger dislike action
            handleDislike();
            break;
        case 'ArrowRight':
            // Trigger like action
            handleLike();
            break;
    }
});

// Navigation items functionality
document.querySelectorAll('nav a').forEach(item => {
    item.addEventListener('click', function(e) {
        const href = this.getAttribute('href');
        if (href === '/liked_music') {
            e.preventDefault();
            
            // Add test_mode parameter if we're in test mode
            const testParam = testMode ? '?test_mode=true' : '';
            window.location.href = '/playlist/view' + testParam;
            return;
        }
        
        if (href.startsWith('/') && href !== '/') {
            e.preventDefault();
            // Remove active class from all items
            document.querySelectorAll('nav a').forEach(i => {
                i.classList.remove('bg-white/15', 'font-semibold');
            });
            // Add active class to clicked item
            this.classList.add('bg-white/15', 'font-semibold');
            
            // Preserve test mode when navigating
            const testParam = testMode ? '?test_mode=true' : '';
            const navUrl = href + testParam;
            
            // Show toast with the name of the clicked section
            const sectionName = this.querySelector('span').textContent.trim();
            showToast(`Navigating to ${sectionName}`);
            
            // Navigate while preserving test mode
            window.location.href = navUrl;
        }
    });
});

// REMOVED: The line below was changing "PLAYLIST" to "Your Playlist"
// document.querySelector('a[href="/liked_music"]').innerHTML = '<i class="fas fa-heart"></i> Your Playlist';

// When the page loads, ensure the background is properly set from the initial album cover
document.addEventListener('DOMContentLoaded', function() {
    // Make sure the background image is properly set on page load
    const initialCoverUrl = albumCover.src;
    if (initialCoverUrl) {
        backgroundContainer.style.backgroundImage = `url('${initialCoverUrl}')`;
    }
    
    // Fix 3: Make sure the initial album link is set correctly
    // Get the current track from the tracks array if it exists
    if (tracks.length > 0) {
        const currentTrack = tracks[currentTrackIndex];
        if (currentTrack && currentTrack.link) {
            albumLink.href = currentTrack.link;
        }
    }
});
    </script>
</body>
</html>